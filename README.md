# ðŸ§¬MetaSwap

Cross-chain swaps with metatransactions

## Overview

MetaSwap is a protocol that leverages metatransactions to enable instant, trustless, 'gassless' swaps between multiple assets, EVM chains, and Lightning invoices.

Currently, MetaSwap allows two parties to swap between any of the following:

- Lightning Network
- Any EVM chain base coin (ETH, ETC, RSK, TRX, etc.)
- Any ERC20 token on any of these chains
- Potentially any other other asset (such as NFTs or other token standards)

Right now MetaSwap is just a technical demo that demonstrates an absolutely minimal proof of concept implementation of the protocol and a basic UI to help understand this flow. This repo includes:

- A contract; MetaSwap.sol in `/contracts/`
- A frontend; metaswap.io in `/app/`

### Demo

A demo version of metaswap is deployed to https://metaswap.io. It is currently only enabled for Lightning Network, Kovan and Rinkeby.

The best way to see how it works is to watch this demo video:

_link to video-here_

## Advantages of MetaSwap

Compared to other swap systems such as atomic swaps or submarine swaps, MetaSwaps have some benefits:

- No servers are required; the whole thing is completable with pure javascript in browser
- Users don't need any existing assets on the chain they wish to on-ramp into
- Swaps are FAST. They are 'confirmed' off-chain, so from the user's point of view they happen instantly, without having to wait for blocks to mined
- Only a single transaction per asset per swap is required; less gas is consumed overall
- The recipient address on either side of the swap can be any address, so users can swap directly into an exchange account or cold storage wallet
- Users can pay for the transaction relay fee in any asset; swaps can happen even if neither party has Ether
- Swaps are effectively settled off-chain, preventing certain types of frontrunning

## How does MetaSwap work?

The system is quite simple, and relies on the following core process.

At least one side of the swap must have have deposited swappable assets in to the MetaSwap.sol contract on an EVM chain. These deposited assets will then be locked for X number of blocks (a cooldown period can be triggered before they are withdrawn again).

Once the swappable funds are deposited, a swap can take place.

- A `preImage` (random string of data) is generated by the `maker` of the swap
- The `maker` hashes this `preImage` to create a `preImageHash`
- The maker offers a the `taker` some amount of an asset that will be sent if the `preImage` is revelaed on chain
- The `taker` agrees to the swap by responding with a `takerRecipient` address
- The `maker` creates and shares a signed metatransaction that will send the funds to the `taker` if the `preImage` is revealed

At this point, the `taker` knows that if the `preImage` is revealed, it can be published along with the `maker`s metatransaction to claim this side of the swap. So how can the `taker` be convinced to reveal the `preImage`?

- In the case of Lightning, The `maker` provides a Lightning Invoice that will reveal the `preImage` upon payment (he generates an invoice and uses the same `preImageHash`).
- In the case of an EVM chain, the `taker`, who has also deposited into MetaSwap.sol, signs a metatransaction with the other side of the swap using the _same_ `preImageHash` as the `maker`, knowing that the `maker` will reveal it on-chain to claim their side of the swap.

This is the basic idea of MetaTransactions; it's pretty similar to submarine swaps.

### Punishment for cheating

But there is an obvious way to cheat this system; either the `maker` or the `taker` can simply publish a bunch of metaswaps to themselves and drain their deposited funds before the legitimate buyer has chance to take out their side of the swap.

However, these is a simple way to make cheating very difficult - by having a rate limit. If either side publishes too many metatransactions, then they will lose all of their funds. The current implementation of this rate limit is based on a proportion of the avilable funds. The default setting for this proportion is 20% -- if one side tries to cheat, he will need to cheat more than 5 parties simultaniously to make a profit, and even this is not guarunteed.

This rate limit approach is pretty basic, and can certainly be improved in future versions. Check out the game theory section to see way of improving this.

## Improvments for future versions

The existing version of MetaSwap is an absolute minimal proof of concept that demonstrates a happy-path scenario. There are various improvements that could be made to improve this MetaSwap reference implementation and/or additional layers to this ecosystem.

- Validation to prevent every edge case
- Ability to submit a proof of fraud to cancel the opposite side of the swap
- Better and fairer punishment systems
- Relayer commitments and punishment for not relaying
- Integration with relay pools such as GTN
- Explore integrating liquidity pools such as Uniswap
- Altenrative signalling servers (not just peer.js)

## Game Theory

TODO
